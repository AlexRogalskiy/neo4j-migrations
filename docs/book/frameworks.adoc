[[Frameworks]]
= Frameworks

This part will speak about the "big" frameworks and what possibilities they offer and how you can hook up your library into them.
This is not about "low level" frameworks, such as a class scanning library, a command line tooling, but more outwards or up the stack.

I am talking about Spring Framework, Spring Boot, Quarkus, Helidon, Micronaut or similar. I will cover Spring Boot and Quarkus here
as those are the ones Neo4j-Migrations offers direct support for.

[[general-considerations]]
== General considerations

All the big frameworks come with a lot of dependencies already. If your library is written in such a way that it uses a ton
of dependencies as well, you or your users end up in dependency issues pretty quickly. I honestly do think that the JDK offers
so many great APIs, being it for all the datastructures you need, sorting algorithms, String and general I/O operations and even
upto HTTP clients (just checkout out `java.net.http.HttpClient` for that matter), that there is often any good reason to
add a heavyweight dependency to your project at all.

Things I have in mind here are `commons-lang`, `guava` and the like: First, look at what the JDK offers for a task at hand
or what is needed to create something decent yourself before you get yourself a couple of megabytes of dependencies.

On the other hand, specialized needs such as connecting to a database with a JDBC implementation or a specialized driver such
as in Neo4js case with the Bolt driver can't be solved within a reasonable amount of work. The same applies to <<ClassGraph>>
for example. ClassGraph is a library I use for scanning the class path for resources and for classes implementing a given interface.
I theoretically could do this all by myself but hardly as good (or as complete) as dedicated library.

However, you should never expose the API of such a library directly on your API. Why? Because if you do, you will be inevitably
glued to the evolution of a third party tool and that is probably not what you want if you like to follow semantic versioning or
things like that. Another reason: Sometimes such an API might not work in a target environment like one of the frameworks to follow,
and you might want to plug-in their solution for the same problem.

[discrete]
=== It's a kind of magic!

The above headline is not only the name of a great Queen song from 1986 accompanying the movie _Highlander_ in which the same statement
is used to "explain" the immortals fighting for "the price", but it can also be used as a question. "Is this a kind of magic?":

[quote, Maciej Walkowiak, https://twitter.com/maciejwalkowiak/status/1495528915535814660]
____
Is
@springboot
still considered as *magic* by anyone or has it already become a default and understood level of abstraction?
____

The discussion following was good and interesting. I have that approach in a talk for a while now. As a user of a car or
even of a computer itself: I don't need to know how the single parts work or work together. To be honest, while I do know
the basic principle of how a combustion engine or an electric engine works, I couldn't care less most of the time. There
are better trained specialists out there who can help me.

It gets more complicated when looking at computer: As a software engineer I better know the basic concepts of I/O, processor,
slow and fast memory and what have you. Should I be able to pick a computer apart and reassemble it? Does it make me a worse
software engineer when I never built my own PC? Should I even be aware how the electronics works? Questionable.

Things a are a bit different for a developer when looking at software: While some bootcamps are probably trying to cookie-cut
as many developers as possible and telling people that at least some computer science knowledge is overrated and frameworks
do all the heavy lifting, this is just not true. You should have a general ideas about complexity, memory usage, runtime behaviour
of algorithms and the like. And you can't get around that you need to know in the end how a target framework of choice behaves.

I firmly believe understanding the mechanics of something like Spring Boot, Micronaut, Quarkus or even Helidon SE (which as a much more
visible and explicit "functional" approach) is paramount, for both a developer using such tech for creating applications and
business value as well as for developers wanting to contribute their thing to a framework.

So here we are, let's break the magician's code once again:

== Spring Boot

A lot has been said already about "the magic" about Spring Boot. Actually, I am one of the people who did start talking about it early on, see
<<a-kind-of-magic-2016>>.
As this is known now by a lot of people and the concept of Spring Boot starter and their autoconfiguration is along now for more than 6 years
actually, I am going to refer to one of my talks from 2016 until the time being: "It's a kind of magic? - Custom Spring Boot Starter"footnote:[https://speakerdeck.com/michaelsimons/its-a-kind-of-magic-custom-spring-boot-starter]

== Quarkus

Quarkus is a framework primarily developed by Red Hat. It is a Java framework tailored for deployment on Kubernetes.
Key technology components surrounding it are OpenJDK HotSpot and GraalVM. The goal of Quarkus is to make Java a leading
platform in Kubernetes and serverless environments while offering developers a unified reactive and imperative programming
model to optimally address a wider range of distributed application architectures. Its first version was published in March 2019.

It has a couple of design principles such as

* Container first
* Developer productivity

Wikipedia lists unifying imperative and reactive as well, but for the purpose of this chapter, the two above will do. Container first
with an emphasis on low memory usage and fast startup times go hand in hand with developer productivity:

image::https://imgs.xkcd.com/comics/compiling.png["Obligatory XKCD (303)",link="https://xkcd.com/303/"]

While I get back to speed of compiling, startup or restart in a moment, other things important for Quarkus are

* unified configuration (Spring Boot has this of course too, and I personally like Springs configuration support better
  than SmallRye's one (SmallRye config is library use by Quarkus))
* "Batteries included" approach: Quarkus uses <<Testcontainer>> for bringing up any downstream service dependencies such as
  databases, message brokers and the like. In case there is explicit configuration for such a service, the so called "Dev services"
  will kick in and bring up a Neo4j database for you for example
* Live coding: Quarkus undertakes some effort to determine whether classes or resources have changed when a request reaches
  an application started in development mode. If so, that class is transparently recompiled and all parts of the application
  affected will restart (that works actually much better than Spring Boots restart class loader)

The fast startup times, the unified configuration and the dev services are all relevant when you want to provide a Quarkus
extension for your library or service. These three points are a good chunk of why the Quarkus extension are designed the way they are.

=== Creating a closed world at build time

The main "trick" inside Quarkus' sleeves is doing as much work and processing during build time to create a closed world.
Closed world meaning that "everything" (i.e. configuration, CDI beans, resources, entities and such) is known before the
startup of an application. That closed world is actually written to bytecode in many cases. Vice versa, stuff outside that
assumption for which can be guaranteed that there's no execution path touching it, will not be loaded into a JVM.

All that goes together with avoiding reflection as much as possible. That would start by finding entities, JAX-RS resources,
over to (re)configuring things during runtime and wiring up collaborators (aka autowiring or injecting things) and many more
stuff we as developers using any framework with dependency injection take for granted.

If the assumption of a closed world sounds familiar: You might have heard in the context of the <<GraalVM>>. More specifically
together with its native image compilation: Turning a proper JVM program into a native machine binary. GraalVM itself removes any
unreachable code found within the application as well as any of its dependencies for the image to be as small as possible.
A native executable starts usually much faster and uses far less memory than a traditional JVM.

NOTE: There are a couple of different approaches to that topic. <<Micronaut>> for examples goes "all in" in terms of annotation processing.
      Or - in the words of their architect Graeme Rocher - "Micronaut is an implementation of an annotation-based programming model."footnote:[https://docs.micronaut.io/latest/guide/index.html#architecture]
      More specifically most if not all the annotations used in Micronaut applications are processed at compile time, not
      at runtime as other frameworks do. "The AnnotationMetadata API is a construct that is used both a compilation time and at runtime by
      framework components. AnnotationMetadata represents the computed fusion of annotation information for a particular type,
      field, constructor, method or bean property and may include both annotations declared in the source code, but also
      synthetic meta-annotations that can be used at runtime to implement framework logic."
      +
      I am pretty sure that Spring Framework 6 and the efforts undertaken at VMWare will move into a similar direction.
      I have written a small annotation processorfootnote:[https://github.com/neo4j-contrib/cypher-dsl/tree/main/neo4j-cypher-dsl-codegen/neo4j-cypher-dsl-codegen-sdn6]
      for Neo4js <<Cypher-DSL>> and the general Java Api for that is well-designed.

[[build-steps]]
==== Build steps

Much of the following is taking straight from "Writing your own extension"footnote:[https://quarkus.io/guides/writing-extensions#bootstrap-three-phases],
a page probably not many casual users of Quarkus will ever open. It does however contain a lot of valuable resources. Most important
to understand the behaviour of your extension and an application eventually using it are the following three distinct phases of bootstrapping
a Quarkus app:

Augmentation:: This initial phase is done via _Build Step Processors_, having access to an index containing annotations found
and ways of access to further descriptors, properties and _build items_ created by previous processors. The outcome of those
build steps can have many forms: It ranges from additional resources put into the applications, hints which classes
to include in a GraalVM native image or (CDI) items available in your final application. Either way, the outcome is recorded into
actual bytecode. Furthermore, all build step processors can interact with _Recorders_. Those records are a way of blue printing
what should be eventually executed, so that it can be recorded into bytecode.
+
Bytecode recorded goes into _one_ of the following phases:

Static init:: The framework is going to create a static method to be called from a main class that is going to initialize as
much of the application as possible.
+
The outcome of the static init phase can be recorded as is during augmentation / build time: Any library needed to produce it
can be dropped from the final class path so that it will never be loaded into the JVM running the application.
+
The static init is even more important for GraalVM native image: The static init is executed on a JVM during ahead-of-time
compilation and any objects retained there are directly serialized into the native executable. This means that if a framework
can boot in this phase then it will have its booted state directly written to the image. Of course this will be then executed
but the computation has already be done at this point.

Runtime init:: Steps recorded here are executed from an applications main method respectively during native executable boot.
There are no restrictions what can be done here. Ports and such can be opened.

It is hopefully apparent that as much as possible should be pushed into static init to achieve the quickest startup possible.

=== Project setup for an extension

Quarkus extensions are usually setup as multi-module projects containing the following modules:

[source,console]
----
neo4j-migrations-quarkus-parent
├── deployment
│   └── src
├── integration-tests
│   └── src
└── runtime
    └── src
----

The parent project is usually responsible for dependency, plugin and build management, while the deployment module contains
all the necessary augmentation code and the runtime module the actual behaviour to be recorded. Integration tests are well,
integration tests.

WARNING: Those are not your usual integration test! To test your extension the best way possible you will have eventually to
         create a real application like module and subject to augmentation. Just like a user would when using your extension.
         I found this to be one of the hardest thing to understand and learn.

The flow of dependencies is crucial to understand: A deployment module actually _must_ depend on the runtime module as
the runtime module will contain the actual recorders and their dependencies. The reason: The recorded bytecode can of course
only be executed when it has access to the runtime classes. A runtime module on the other hand _must not_ dependent on the
deployment module as that would pull in all Quarkus augmentation and deployment code into the runtime, quite the contrary of
what should be achieved.

On the other hand, deployment modules are of course allowed to depend on other deployment modules so that module `B` can consume
any build items from `A` and use them. The same applies for runtime modules: They are free to depend on other runtime modules.

[TIP]
====
The Quarkus people use Maven a lot. The make use of artifacts and extensions in a couple of places. Basically, using de-jure
or de-facto standards for getting you up to speed and running. You can use

[source]
----
mvn io.quarkus:quarkus-maven-plugin:create-extension \
  -DextensionId=my-ext \
  -Dname="My extension"
----

to create a new extension. The process will ask you for a group id and depending on that, you will end up with a "standalone"
layout, the "Quarkiverse"footnote:[https://github.com/quarkiverse] layout (in case your group id starts with `io.quarkiverse.`)
or from within the Quarkus source tree itself, the "Quarkus core" layout.
====

=== The effect on Neo4j-Migrations

How does the above restrictions respectively the philosophy affect Neo4j-Migrations and what can I enlist to demonstrate the 
possibilities of a good deployment module? A couple of things, as it turns out:

First, Neo4j-Migrations depends on another deployment module, namely the Quarkus-Neo4j extension. How to access its primary 
build item.

Neo4j-Migrations searches for resources (Cypher-Scripts) in both the class path as well as the file system. The latter is less
than a problem then the former: The file  system is of course always accessible (well, mostly always), regardless if things are
run on the JVM or native image. The class path is certainly accessible as well, but as we learned before, stuff that is not 
accessed at build time or explicitly declared to be included in the image just won't be there.

The same rules apply for Java (or Kotlin for that matter) implementations of `JavaBasedMigration` (an interface that allows for
programmatic migrations). 

While resources and classes will always appear in the Quarkus JVM based output, they won't appear in a GraalVM native image 
without additional hints (compare <<GraalVMTooling, the tooling available for creating native GraalVM images>>). We are lucky,
Quarkus offers a couple of hints that will make sure that classes and resources are both read during startup and appear in a 
native image.

Furthermore, I wanted to make sure that a `Migrations` instance is available as CDI bean, so that a user can access it and 
call for `info`, `clean` and other operations.

And last but not least, can we add some decent information to the developer console? Let's have a look at each of the above
points.

TIP: The relevant Quarkus code of Neo4j-Migrations is in this module and its submodules: https://github.com/michael-simons/neo4j-migrations/tree/1.4.0/neo4j-migrations-quarkus-parent[neo4j-migrations-quarkus-parent],
     The main processor is of course in the deployment module https://github.com/michael-simons/neo4j-migrations/blob/6b6064c69d7429411e420895bafca8b4ac850fb2/neo4j-migrations-quarkus-parent/deployment/src/main/java/ac/simons/neo4j/migrations/quarkus/deployment/MigrationsProcessor.java#L65[`ac.simons.neo4j.migrations.quarkus.deployment.MigrationsProcessor`]
     and the main recorder is https://github.com/michael-simons/neo4j-migrations/blob/6b6064c69d7429411e420895bafca8b4ac850fb2/neo4j-migrations-quarkus-parent/runtime/src/main/java/ac/simons/neo4j/migrations/quarkus/runtime/MigrationsRecorder.java#L39[`ac.simons.neo4j.migrations.quarkus.runtime.MigrationsRecorder`.]
     +
     *Every* method annotated with `@BuildStep` lives in a processor!

==== Declaring the feature

This is the easiest step of them all:

[[createFeature]]
[source,java]
.MigrationsProcessor#createFeature
----
include::../../neo4j-migrations-quarkus-parent/deployment/src/main/java/ac/simons/neo4j/migrations/quarkus/deployment/MigrationsProcessor.java[tag=createFeature,indent=0,tabsize=2]
----

It is a `FeatureBuildItem` which just indicates a name for the feature provided by the extensions.

NOTE: What's with the `@SuppressWarnings("unused")`: That's the downside of "magic" code: The `@BuildStep` gets invoked by
      the Maven plugins, so a static analyzer like Sonar (and most IDEs) have a hard time figuring out that this method is
      actually used. I spent enough time on the quadruple A-Rating in https://sonarcloud.io/summary/overall?id=eu.michael-simons.neo4j%3Aneo4j-migrations-parent[sonarcloud]
      which I don't want to be spoiled with false positive of unused code.

==== Depending on another deployment module

Neo4j-Migrations needs a connection to the Neo4j database it should be used with. This connection is provided via an instance
of Neo4js `Driver`. That driver comes from Quarkus Neo4j.
As the driver instance is of course a runtime dependency - it's a bit hard to create a persistent database connection
during build time and then serialize it to byte code - we need to depend on the corresponding deployment module from our
own deployment module of course:

[[quarkus-neo4j-deployment-dependency]]
[source,xml]
.pom.xml (in deployment)
----
include::../../neo4j-migrations-quarkus-parent/deployment/pom.xml[tag=quarkus-neo4j-deployment-dependency,indent=0,tabsize=2]
----

And the for full measurement, the runtime dependency in the runtime module:

[[quarkus-neo4j-dependency]]
[source,xml]
.pom.xml (in runtime)
----
include::../../neo4j-migrations-quarkus-parent/runtime/pom.xml[tag=quarkus-neo4j-dependency,indent=0,tabsize=2]
----

Now, how to use it? We must step ahead to the build step that puts everything together. It looks like this:

[[createMigrations]]
[source,java]
.MigrationsProcessor#createMigrations
----
include::../../neo4j-migrations-quarkus-parent/deployment/src/main/java/ac/simons/neo4j/migrations/quarkus/deployment/MigrationsProcessor.java[tag=createMigrations,indent=0,tabsize=2]
----
<.> Remember what has been said in <<build-steps>>? This annotation moves the bunch of code
    eventually into runtime. The main reason here being the fact that we cannot longer postpone the access to a valid
    physical database connection
<.> This is a build item produced by a different extension. By declaring it as a method parameter, the build-plugins will
    inject those items during build time for you
<.> Here we retrieve the value from the build item. Be aware, it's return type is actually a `RuntimeValue<Driver>`.
    The name is true to its nature: It is a value only accessible during runtime. It *cannot*  be used
    here.

The usage of the runtime value of another extension must happen in a recorder in the runtime module.
<<recordMigrations>> shows the relevant piece of the recorder and actually the smallest one in terms of LoC: All the heavy lifting
has been done while creating the config:

[[recordMigrations]]
[source,java]
.MigrationsRecorder#recordMigrations
----
include::../../neo4j-migrations-quarkus-parent/runtime/src/main/java/ac/simons/neo4j/migrations/quarkus/runtime/MigrationsRecorder.java[tag=recordMigrations,indent=0,tabsize=2]
----
<.> Marks the class as `@Recorder`. Any processor method annotated with `@Record(ExecutionTime.RUNTIME_INIT)` must declare
    an argument being a recorder.
<.> Both parameters passed to `recordMigrations` are runtime values. Only here (and actually, only when the byte code created with this method)
    is executed, access to the runtime values value is possible.

==== Properties and configuration

To quote the Quarkus manual:

> Some Quarkus configurations only take effect during build time, meaning is not possible to change them at runtime.
> These configurations are still available at runtime but as read-only […].
> A change to any of these configurations requires a rebuild of the application itself to reflect changes of such properties.

Which makes perfectly sense in terms of <<build-steps>>: The more things are settled during build, the more things can be
written in +++<s>stone</s>+++ bytecode.

So there 4 different configuration phases:

* build time: Values are read and available for usage at build time.
* build and runtime fixed: Values are read and available for usage at build time, and available on a read-only basis at run time.
* bootstrap: Values are read and available for usage at run time and are re-read on each program execution.
* run time: Values are read and available for usage at run time and are re-read on each program execution.

Phases that are relevant for Neo4j-Migrations are build and runtime fixed as well as runtime.
In therms of numbers, most options for Neo4j-Migrations are actually runtime options (compare the list https://michael-simons.github.io/neo4j-migrations/1.4.0/#usage_spring-boot_all-properties[here]),
such as the schema database or the target database (they might change depending on the URL (which is also runtime)) as well
as the name of the user who executed the migration and which user to impersonate. It's just fair
to assume that when an application is connected to a different database, those change.

They go in a properties class annotated with `@ConfigRoot` indicating its phase as `ConfigPhase.RUN_TIME`:

[[MigrationsProperties]]
[source,java]
.MigrationsProperties (Excerpt)
----
include::../../neo4j-migrations-quarkus-parent/runtime/src/main/java/ac/simons/neo4j/migrations/quarkus/runtime/MigrationsProperties.java[tag=MigrationsProperties,indent=0,tabsize=2]
----
<.> A way out of the build time properties later on.

Our build time properties is a lot smaller and the whole class fits in the book:

[[MigrationsBuildTimeProperties]]
[source,java]
.MigrationsBuildTimeProperties.java
----
include::../../neo4j-migrations-quarkus-parent/runtime/src/main/java/ac/simons/neo4j/migrations/quarkus/runtime/MigrationsBuildTimeProperties.java[tag=MigrationsBuildTimeProperties,indent=0,tabsize=2]
----

Both these classes live in the runtime module and the only technical difference is the phase. In the <<MigrationsBuildTimeProperties>>
it is `ConfigPhase.BUILD_AND_RUN_TIME_FIXED`: The source of those properties is consulted during build time, passed to the system,
evaluated in a sensible way and eventually written to byte code.

And what should be pushed into build time? Discovering of classes and resources! Both of which Neo4j-Migrations
need to do its refactoring work.

Why the `externalLocations` property during runtime? This is an additional feature that allows to
configure filesystem only locations for those cases in which they aren't any migrations to discover during build but
instead are stored completely independent of the application.

How to access these properties? They must be injected into `@BuildSteps`, <<createMigrations>> being one example. It receives
both build- and runtime properties. <<createDiscoverer>> is one more example coming up:

==== Discovering and registering resources and classes during deployment

Quarkus uses <<Jandex>> for discovering and indexing classes (of a given type, with certain annotations or listed in configuration files).
The documentation is a bit sparse around that topic, but Baeldungfootnote:[https://www.baeldung.com/quarkus-bean-discovery-index] has you covered.
The index can be accessed through the core build items `BeanArchiveIndexBuildItem` and `CombinedIndexBuildItem`.
The latter allows programmatically adding classes to the index via a computing view on the index:
When a class is asked for by name, it will be added automatically.

[[createDiscoverer]]
[source,java]
.MigrationsProcessor#createDiscoverer
----
include::../../neo4j-migrations-quarkus-parent/deployment/src/main/java/ac/simons/neo4j/migrations/quarkus/deployment/MigrationsProcessor.java[tag=createDiscoverer,indent=0,tabsize=2]
----

Remember what I said in <<general-considerations>> about abstracting away any third-party API you might be using? This is the
part where it becomes relevant. While I do love <<ClassGraph>>, it is not the perfect candidate for the task at hand: Discovering
resources and classes in a Quarkus build environment. While it worked in Quarkus 2.6, things broke in 2.7. Together https://twitter.com/lh[@lh]
I was able to fix this, but I was convinced to try Quarkus way.
In case you're interested in the abstraction itself: It's called `Discoverer<JavaBasedMigration>` and
it lives in `neo4j-migrations-core` inside the `neo4j-migrations-core` package. In most scenarios it uses the
ClassGraph implementation, in Quarkus it is a `StaticJavaBasedMigrationDiscoverer`
that is preloaded during build time with a fixed set of classes.

I spare you the gory details of `findClassBasedMigrations` and just pick the essential part:

[source,java]
.Asking the Jandex for all implementors of a given interface:
----
var dotName = DotName.createSimple(JavaBasedMigration.class.getName());
indexView
    .getAllKnownImplementors(dotName)
    .forEach(classInfo -> {
        // Do things with the classInfo found
        // For example loading it:
        try {
            Thread.currentThread().getContextClassLoader()
                .loadClass(cf.name().toString())
                .asSubclass(JavaBasedMigration.class);
        } catch (ClassNotFoundException e) {
            // Whatever
        }
    });
----

If you need access to class during build time, it must be loaded with the current threads classloader.
Now what to do with those classes? I first create a `DiscovererBuildItem` in <<createMigrations>>.
`DiscovererBuildItem` is a custom class, shown in the following listing:

[source,java]
.DiscovererBuildItem.java
----
include::../../neo4j-migrations-quarkus-parent/deployment/src/main/java/ac/simons/neo4j/migrations/quarkus/deployment/DiscovererBuildItem.java[tag=DiscovererBuildItem,indent=0,tabsize=2]
----

This build item can be passed along as needed. And it is needed indeed: It is not enough to tell Neo4j-Migrations core
"here are a set of classes", but these classes need to be registered for reflections as they are - most likely - never
called from application code and therefore removed.

A `ReflectiveClassBuildItem` to the rescue. This is a build in class that is used like this:

[[registerMigrationsForReflections]]
[source,java]
.MigrationsProcessor#registerMigrationsForReflections
----
include::../../neo4j-migrations-quarkus-parent/deployment/src/main/java/ac/simons/neo4j/migrations/quarkus/deployment/MigrationsProcessor.java[tag=registerMigrationsForReflections,indent=0,tabsize=2]
----

The boolean parameters corresponds which parts are eligible for reflection (constructor, methods, fields).

Last but not least: Why are resources (like in Cypher-script files) also build time fixed? Because they must be explicitly
included in the native image when compiled via GraalVM, otherwise they are kept out. The abstraction of discovering is similar
to searching for classes, you can find it in the processor, too.

They key to have resources in the native image is the `NativeImageResourceBuildItem`:

[[addCypherResources]]
[source,java]
.MigrationsProcessor#addCypherResources
----
include::../../neo4j-migrations-quarkus-parent/deployment/src/main/java/ac/simons/neo4j/migrations/quarkus/deployment/MigrationsProcessor.java[tag=addCypherResources,indent=0,tabsize=2]
----

TIP: Quarkus offers some ways to create additional resources during build. These most be added explicitly
     to native as well, this is not done automatically.

==== Adding synthetic beans

As a final step, I wanted the user to be able to access the `Migrations` object in their (CDI) code and if enabled,
execute migrations as soon as the Quarkus application starts.

The former is done via a  `BuildProducer<SyntheticBeanBuildItem>` dependency, seen in <<createMigrations>>.
Such a producer is a way to return multiple (different) build items from a build step. Here, I add the configuration
and migrations bean as `SyntheticBeanBuildItem`.

Last but not least, things happening on startup is done via a `ServiceStartBuildItem`.
What is passed to a startup build item needs to be recorded in the build step producing the item as shown in <<applyMigrations>>:

[[applyMigrations]]
[source,java]
.MigrationsProcessor#applyMigrations
----
include::../../neo4j-migrations-quarkus-parent/deployment/src/main/java/ac/simons/neo4j/migrations/quarkus/deployment/MigrationsProcessor.java[tag=applyMigrations,indent=0,tabsize=2]
----

==== Contributing to the developer console

I tried to cover what's possible in a small video https://michael-simons.github.io/neo4j-migrations/current/#devservicesintegration[here].
These things are usually done via an additional processor if they have some dynamic nature or just with "plain" https://quarkus.io/guides/qute[Qute template].

In terms of dynamic features (like in our case, accessing the `Migrations` bean and calling methods on it), there's an SPI for
that allowing to register VertX-HTTP based handlers.

In terms of build time and runtime behaviour they are similar to what has been discussed above, in terms of SPI I did read
some Quarkus source code.

=== Quintessence

Without deep understanding how a framework - in this case Quarkus *and* the underlying target deployment of GraalVM native - works,
it is not really possible to integrate an like Neo4j-Migrations in an meaningful way.

But I'd go a step further: Without understanding the implications of deployment augmentation and runtime behaviour: The startup
time, the quick turnaround, it's nice and shiny, but it's too easy to miss on something when things go wrong.

My recommendation: For a "day 2" scenario, make sure what kind of target environment you have.